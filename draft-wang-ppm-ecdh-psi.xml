<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc version 1.7.17 (Ruby 2.6.10) -->


<!DOCTYPE rfc  [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">

]>


<rfc ipr="trust200902" docName="draft-wang-ppm-ecdh-psi-latest" category="info" tocInclude="true" sortRefs="true" symRefs="true"  submissionType="IETF">
  <front>
    <title abbrev="ECDH-PSI">PSI based on ECDH</title>

    <author initials="Y" surname="Wang" fullname="Yuchen Wang">
      <organization>Ant Group</organization>
      <address>
        <email>tianwu.wyc@antgroup.com</email>
      </address>
    </author>
    <author initials="W" surname="Chang" fullname="Wenting Chang">
      <organization>Ant Group</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>Beijing</city>
          <code>D-28359</code>
        </postal>
        <phone>+49-421-218-63921</phone>
        <facsimile>+49-421-218-7000</facsimile>
        <email>bainuan.cwt@antgroup.com</email>
      </address>
    </author>

    <author initials="Y" surname="Lu" fullname="Yufei Lu">
      <organization>Ant Group</organization>
      <address>
        <email>yuwen.lyf@antgroup.com</email>
      </address>
    </author>

    <author initials="C" surname="Hong" fullname="Cheng Hong">
      <organization>Ant Group</organization>
      <address>
        <email>vince.hc@alibaba-inc.com</email>
      </address>
    </author>

    <author initials="J" surname="Peng" fullname="Jin Peng">
      <organization>Ant Group</organization>
      <address>
        <email>jim.pj@antgroup.com</email>
      </address>
    </author>

    <date year="2025" month="February" day="17"/>

    <area>Security Area</area>
    <workgroup>Privacy Preserving Measurement</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<?line 55?>

<t>
<!--Private Set Intersection (PSI) protocols can facilitate the determination of common elements
across different parties' datasets without disclosing the individual dataset contents, and have been widely deployed by the industry.-->

This document describes Elliptic Curve Diffie-Hellman Private Set Intersection (ECDH-PSI) for 2 participants.
It instantiates the classical Meadows match-making protocol with standard elliptic curves and hash-to-curve methods, enabling the participants to find common records in a privacy-respecting way.
In ECDH-PSI, records are encoded to points on an elliptic curve, and masked by the private keys of both participants.
To compute the intersection, a participant only uses the jointly masked datasets and its original dataset locally, which prevents its partner from learning the private records not in the intersection.
</t>
</abstract>



  </front>

  <middle>


<?line 69?>

<section anchor="introduction"><name>Introduction</name>


<t>Private Set Intersection (PSI) schemes enable the discovery of shared elements among different parties' datasets without revealing individual data.
They are widely used to identify overlapping data elements between two or more parties
while preserving the confidentiality of each party's original data.

PSI is one of the most frequently used privacy preserving techniques in business.
It enables a user to detect whether his/her password is leaked without giving away the password to the server <xref target = "MS21"/>, and allows multiple companies to find their common customers without revealing raw data.

Furthermore, many privacy-respecting systems can leverage PSI schemes to collaborate with other data providers for the purpose of enhancing the privacy of data-exchange processes.
As an example, a service provider who has aggregated attributes from individuals following <xref target = "I-D.ietf-ppm-dap"/><xref target = "draft-irtf-cfrg-vdaf-12"/> can use PSIs to compare its results with another entity without disclosing any attribute not owned by the partner.


<!--Based on PSI, the participants could collaborate and extract valuable insights with their data in a privacy-respecting manner, and enhance the privacy of many business sectors such as joint marketing, advertisement, and risk control.-->
</t>

<t>
The classical Diffie-Hellman PSI <xref target = "Meadows86"/> has been published for more than thirty years.
The academic has also proposed numerous PSI schemes with new functionalities and secure guarantees, such as <xref target = "KKRT16"/><xref target = "CHLR18"/><xref target = "RR22"/>, but DH-PSI is still preferable due to its simplicity and communication efficiency.
This document describes a widely deployed instance of DH-PSI denoted by Elliptic Curve Diffie-Hellman PSI (ECDH-PSI).
Compared with the finite field parameters used in the classical version, elliptic curves are commonly considered to be more efficient and secure <xref target = "IMC"/><xref target = "LOGJAM"/>, and are extensively adopted by recent standards including <xref target = "RFC8031"/><xref target = "RFC8446"/><xref target = "RFC9497"/>.
</t>

<t>
This document describes 2-party ECDH-PSI as a two-phase protocol, including a handshake phase which negotiates parameters such as cipher suites and a data exchange phase which transfers masked datasets.
At the end of data exchange phase, one or both parties output the intersection result.
</t>

<section anchor="requirement_terminology"><name> Requirements Terminology</name>
<t>
The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
    described in BCPÂ 14 <xref target="RFC2119" format="default" sectionFormat="of" derivedContent="RFC2119"/> <xref target="RFC8174" format="default" sectionFormat="of" derivedContent="RFC8174"/>
    when, and only when, they appear in all capitals, as shown here.
</t>
</section>

<section anchor = "notations"><name>Data Structures and Notations</name>
<t>
In this document, data structures are defined and encoded according to the conventions laid out in Section 3 of <xref target = "RFC8446"/>.
</t>
<t>The following notations are used throughout this document:</t>
<t>
<ul spacing="normal" bare="false" empty="false" indent="0">
<li><tt>sqrt(x)</tt>: The square root of <tt>x</tt>.</li>
<li><tt>log(x,y)</tt>: The logarithm of <tt>y</tt> to the base <tt>x</tt>. </li>
<li><tt>x^-1</tt>: The inverse of <tt>x</tt> (over a finite field). </li>
<li><tt>x||y</tt>: Concatenate string <tt>x</tt> and <tt>y</tt>.</li>
<li><tt>intersection(set_1,set_2)</tt>: The intersection of <tt>set_1</tt> and <tt>set_2</tt> </li>
<li><tt>|set|</tt>: The cardinality of <tt>set</tt>.</li>
</ul>
</t>
</section>

</section> <!-- Ending to Introduction -->


<section anchor="background"><name> Background</name>
<t>This section gives brief introductions for elliptic curves, hash-to-curve methods and the Transport Layer Security (TLS) protocol.</t>
<section anchor="background_ec"><name> Elliptic Curves</name>
<t>
An elliptic curve E is defined by a two-variable equation over a finite field F with prime characteristic p larger than three.
Except for a special point called point at infinity, a point on E is a (x,y)-coordinate pair that satisfies the curve equation, where x and y are elements of F.
All distinct points of curve E constitute an algebraic group of order n, where the point at infinity is the identity element.
Applications and standards generally use a prime order (sub)group &lt;G&gt; generated by a point G on E.
The order of &lt;G&gt; is denoted by r.
</t>

<t>
This document uses term "addition" to refer to the group operation of an elliptic curve group, meaning two points P and Q can be added together to get a third point R.
Scalar multiplication refers to the operation of adding a point P with itself repeatedly.
This document uses <tt>scalar_mul</tt> to denote the scalar multiplication process.
It takes an integer x&lt;r and a point P as inputs and outputs the multiplication result Q, which is written by <tt>Q=scalar_mul(P,x)</tt> or simply <tt>Q=P^x</tt>.
When <tt>set_p</tt> is a set of EC points, <tt>set_m=set_p^x</tt> denotes that all elements of <tt>set_p</tt> are multiplied by <tt>x</tt> to obtain <tt>set_m</tt>.
</t>

<t>Many cryptographic applications require the participants to generate elliptic curve key pairs.
Usually, a key pair refers to a <tt>(PK,sk)</tt> tuple, where <tt>sk</tt> is an integer generated uniformly between 1 and r-1, and <tt>PK=scalar_mul(G,sk)</tt>.
In the context of ECDH-PSI, only <tt>sk</tt>, namely the private key, is used.
Thus, this document uses the notation <tt>sk=keygen()</tt> to refer to the process of generating a private key on the elliptic curve and omits <tt>PK</tt>.
</t>

</section>

<section anchor="background_hash_ec"><name>Hashing to Elliptic Curves</name>

<t>A hash_to_curve function <xref target="RFC9380"/> encodes data of arbitrary length to a point on an elliptic curve.
The encoding process first hashes the byte string to elements of fixed length, and then calculates a point on the curve with the elements using so-called map_to_curve and clear_cofactor functions.
</t>

<t>
<xref target="RFC9380"/> describes a series of hash_to_curve methods (which are also called "suites") for standard curves such as NIST P-256 and curve25519.
It specifies two encoding types denoted by "encode_to_curve" and "hash_to_curve".
Both encodings can be proven indifferentiable from random oracles (ROs)<xref target = "MRH04"/>, but have different output distributions.
This document only uses "hash_to_curve" encodings which output uniformly random points.
It also uses the notation <tt>set_p=hash_to_curve(set_d)</tt> to refer to the process of encoding
every elements in <tt>set_d</tt> to points on a curve and obtains <tt>set_p</tt>.
</t>

<t><xref target="RFC9380"/>  requires all uses of the hash_to_curve suites must enforce domain separation with domain separation tags (DSTs).
In particular, DSTs are distinct strings that enable different applications to simulate distinct RO instances with the same hash function.
To meet the requirement of DSTs, this document allocates each suite with a unique DST, and uses the notation of <tt>set_p=hash_to_curve(set_d)</tt> assuming that the corresponding DST strings have been taken as internal inputs.
</t>

<t>
A suite defined by <xref target="RFC9380"/> includes a series of parameters such as the curve, hash function, and encoding type.
In applications, these suites are very efficient to be referred to, as the included parameters can also be used beyond the scenario of mapping data to curves.
For example, the participants can negotiate a hash_to_curve suite, and then use the curve deduced from the suite for other cryptographic functions such as encryption and key establishment.
</t>

<t>
To extend the usage of hash_to_curve suites, <xref target="RFC9380"/> also describes methods and naming conventions for defining new suites, which enables developers to define suites with new curves and hash functions.
</t>
</section>

<section anchor = "background_tls"><name>Transport Layer Security</name>
<t>
The TLS protocol <xref target="RFC8446"/> has been widely used for secure communication over the Internet.
It operates over any underlying communication channel that provides reliable, in-order data stream, ensuring important security properties of authentication, confidentiality and integrity.
In particular, TLS provides mutual authentication methods so that the peers can authenticate each other.
It also uses DH key exchange to establish session keys and employs authenticated encryption to guarantee that the transferred messages are encrypted and not manipulated.
</t>

<t>
The notion of "channel binding" is originally proposed by <xref target="RFC5056"/>, which enables applications to bind authentication to secure sessions at lower layers in the network stack so as to prevent the so-called Man-In-The-Middle (MITM) attack.
To extend the notion to TLS, <xref target="RFC9266"/> presents a method of binding applications to the underlying TLS 1.3 sessions, which is denoted by 'tls-exporter'.
It outputs exported keying material (EKM) established by the TLS session, which can be seen as the output of a pseudorandom function (PRF) based on TLS.
The application can bind to the TLS session by taking EKM as an input to the application-layer cryptographic session.

</t>

</section>

</section> <!-- Conventions and Notation -->


<section anchor = "protocol" pn = "section-3"><!-- Protocol 3 -->
<name>Protocol</name>

<!--t indent = "0">
ECDH-PSI allows two participants, A and B, to compute the intersection of their data sets in a privacy-preserving manner,
ensuring that data does not in the intersection is not revealed.
The intersection result could be obtain by both participants or by only one of them.
</t-->


<t indent = "0">
We begin with a very brief description on how ECDH-PSI works.
Firstly, the participants, A and B, agree on a group &lt;G&gt; along with the hash_to_curve suites, and generate fresh private keys over &lt;G&gt;.
Then, both A and B convert their records to points over &lt;G&gt; and multiply the points with both parties' private keys for masking.
Finally, they exchange the sets of masked elements, compute their intersection, and match the intersections with original datasets locally.
</t>

<t indent = "0">
To prepare the ECDH-PSI protocol, A and B need to:
<ul>
<li> Establish a TLS channel with mutual authentication. </li>
<li> Negotiate the parameters used for subsequent steps, especially the hash_to_curve suite. </li>
<li> Generate EC private keys with <tt>sk_A=keygen()</tt> and <tt>sk_B=keygen()</tt>.
These keys are also denoted by "ECDH-PSI keys", and only used in current ECDH-PSI session. </li>
</ul>
</t>

<t indent = "0">
After the preparation, assume that A has <tt>set_A</tt>, B has <tt>set_B</tt>, a simplified protocol flow of ECDH-PSI is shown by <xref target="fig-1"/>, and explained step-by-step as follows:
<list style="numbers" type="1">
  <li>
  Each participant maps its records to EC points with <tt>hash_to_curve</tt>,
  and masks the points locally with its own private key by <tt>scalar_mul</tt>.
  In this step, the ECDH-PSI session is bound to the underlying TLS session with the channel binding mechanism introduced by <xref target = "background_tls"/>.
  We defer the details of session binding to <xref target = "data_exchange"/>.
  </li>
  <li>
  A and B exchange their locally masked sets <tt>pset_A</tt> and <tt>pset_B</tt>.</li>
  <li>
  Upon receiving the masked data from its partner, a participant masks the received points with its private key.</li>
  <li>
  Each participant sends the jointly masked set (i.e., <tt>pset_BA</tt> and <tt>pset_AB</tt>) back to its partner.
  <!--This step is only executed when the the partner is required to output the PSI result.--></li>
  <li>
  <!-- (Optional) If a participant is required to output the PSI result, -->
  Each participant calculates intersection of the set calculated in Step 3 and the set received in Step 4, matches the original data set with the intersection, and finally outputs the matching result.
  </li>
</list>
</t>
<t>
In order to clarify the statement, this document uses "the first round" or "round 1" to refer to  Step 2, and "the second round" or "round 2" for Step 4.
</t>
<t>
The classical description of ECDH-PSI enables both parties to output PSI results and thus requires two complete rounds (i.e. Step 2 and Step 4) to exchange masked data.
However, many application scenarios require that only one participant (commonly, the participant who initiates the session) should output the intersection and the other gets nothing.
In such scenarios, Step 4 and Step 5 are executed unidirectionally,
where only one party sends jointly masked data in Step 4 and only the receiver of that message can output the result.
</t>

<t indent = "0">
To output PSI result, the participants should also match the original data items with their corresponding masked EC points.
In particular, the relationship can be established with unique indexes,
where an original data record and corresponding masked EC point(s) are linked to the same index.
</t>

<figure title="A Simplified Protocol Flow of ECDH-PSI" anchor="fig-1">
<artwork>
<![CDATA[

              A(set_A,sk_A)                   B(set_B,sk_B)
-----------------------------------------------------------------------
Step 1:             |                               |
                    |                               |
     pset_A=hash_to_curve(set_A)^sk_A   pset_B=hash_to_curve(set_B)^sk_B
                    |                               |
Step 2:             |                               |
                    |                               |
                    |------------pset_A------------>|
                    |<-----------pset_B-------------|
                    |                               |
Step 3:             |                               |
                    |                               |
          pset_BA=pset_B^sk_A             pset_AB=pset_A^sk_B
                    |                               |
                    |                               |
                    |                               |
Step 4:             |                               |
                    |                               |
                    |-----------pset_BA------------>|
                    |<----------pset_AB-------------|
                    |                               |
Step 5:             |                               |
                    |                               |
    rset_A=intersect(pset_BA,pset_AB)   rset_B=intersect(pset_AB,pset_BA)
                    |                               |
                    |                               |
         output match(set_A,rset_A)       output match(set_B,rset_B)
                    |                               |
]]>
</artwork>
</figure>

<section anchor = "overview">
<name>Overview</name><!-- Overview 3.1 -->

<t indent = "0">
The specification of ECDH-PSI consists of two phases as shown in <xref target="fig-2"/>,
including a handshake phase which negotiates the protocol parameters
and a data exchange phase that performs the operations described by <xref target="fig-1"/>.</t>

<t indent = "0">
<ul spacing="normal" bare="false" empty="false" indent="2">
  <li>
  In the handshake phase, a participant, which is denoted by requester, sends a <tt>HandshakeRequest</tt> message to initiate the ECDH-PSI protocol flow.
  This message carries lists of parameters supported by the requester.
  Then, the other participant, denoted by responder, selects parameters from the requester's lists, and sends the parameters with its data information in a <tt>HandshakeResponse</tt> message.</li>
  <li>
  Next, in the data exchange phase, both parties perform ECDH-PSI operations with parameters selected in the handshake phase, where <tt>EcdhPsiBatch</tt> messages carrying masked EC points are exchanged.
  <!--The receiver of an <tt>EcdhPsiBatch</tt> replies with a <tt>EcdhPsiBatchResponse</tt> message,
  which tells sender the handling status of last <tt>EcdhPsiBatch</tt> message.-->
  <!--The number of <tt>EcdhPsiBatch</tt> messages, and the size of each <tt>EcdhPsiBatch</tt> messages are determined by parameters chosen in the handshake phase,
  and the limitation of network or computation resources.
  A participant could also divide its data into multiple messages, and use the <tt>is_last_batch</tt> field to tell its partner whether all data has been sent.
  -->
  </li>
</ul>
In the second round, the <tt>EcdhPsiBatch</tt> message sent from the requester is optional since the requester may not allow the responder to output the intersection, which is determined in the handshake phase.
</t>

<!--t>
This specification enables masked data to be transferred in many batches, as the entire data set may be extremely large and requires numerous resources to be handled properly.
For example, the size of a data set may exceed the limit of a single package of the underlying network protocol.
The participants can divide the data set to multiple batches and use multiple <tt>EcdhPsiBatch</tt> messages to send them so as to meet the limits of network, storage or computation resources.
</t-->

<!--t>
Besides hash_to_curve suites and data formats, the handshake phase also determines the interaction pattern for data exchange phase. The pattern is decided by the following options:
</t>

<ul spacing="normal" bare="false" empty="false" indent="2">
  <li>The participant that outputs the result.
  If only the requester


  participant (for example, A) has the privilege of obtaining the result, then, in the second round, <tt>EcdhPsiBatch</tt> messages will be only sent from B to A.
  </li>
  <li>The maximum size of a single <tt>EcdhPsiBatch</tt> message.
  Upon the determination of maximum batch size, the participants can deduce the number of batch messages sent or received in each round by dividing the size of entire data set with the maximum size.
  </li>
  <li>The order of sending <tt>EcdhPsiBatch</tt> messages.
  When both participants need to send batch messages in the same round, the requester will always send the first one.
  Then, they can send <tt>EcdhPsiBatch</tt> messages in turn, or let the requester send all batches in sequence before the responder sending its data.
  </li>
</ul-->

<!--t>
It is possible that only one party sends doubly-masked data to its partner in the second round-trip,
since both participants may agree on only one of them has the privilege of obtaining the PSI result.
In the case that both participants decide to use multiple <tt>EcdhPsiBatch</tt> messages in the same round-trip,
</t-->




<figure title="An Overview of the Two-Phase Specification of ECDH-PSI" anchor="fig-2">
<artwork>
<![CDATA[

             A(requester)                          B(responder)
-----------------------------------------------------------------------
                  |                                     |
Handshake Phase:  |                                     |
                  |----------HandshakeRequest---------->|
                  |<---------HandshakeResponse----------|
                  |                                     |
Data Exchange     |
Phase:            |                                     |
                  |                                     |
                  |-------------EcdhPsiBatch----------->|
                  |<------------EcdhPsiBatch------------|
                  |                                     |
                  |--------EcdhPsiBatch(optional)------>|
                  |<------------EcdhPsiBatch------------|
                  |                                     |
]]></artwork></figure>

</section>

<section anchor="handshake"><name>Handshake</name><!-- Handshake 3.2-->
<t indent = "0">
The handshake phase includes a <tt>HandshakeRequest</tt> and a <tt>HandshakeResponse</tt> message.
The structures of these messages are documented as follows.
</t>

<section anchor="hk-request"><!-- HandshakeRequest 3.2.1-->
<name>HandshakeRequest</name>

<t indent = "0">Structure of <tt>HandshakeRequest</tt>:
</t>
  <sourcecode>
  struct {
    uint8 version;
    uint8 output_mode;
    uint64 record_num;
    ProtocolProposal protocol_param;
  } HandshakeRequest;
  </sourcecode>
<t indent = "0">
<tt>version</tt>: The version of ECDH-PSI protocol. Currently only value <tt>1</tt> is allowed.</t>

<t indent = "0">
<tt>record_num</tt>: The number of requester's data records.</t>

<t indent = "0">
<tt>output_mode</tt>: Whether the responder is allowed to output the result, which also decides whether the optional <tt>EcdhPsiBatch</tt> is sent in the second round.
The meaning of <tt>OutputMode</tt> is explained as follows:


<list style = "symbols">
<t>
<tt>0</tt>: Both parties output the intersection result, which means <tt>EcdhPsiBatch</tt> are sent mutually in the second round.
</t>
<t>
<tt>1</tt>: Only the requester outputs PSI result, which means only the responder sends <tt>EcdhPsiBatch</tt> in the second round.
</t>
</list>

</t>
<!--t indent="0">
  requester_rank: Requester's rank, which is used to identify the requester during the ECDH-PSI protocol.
  The requester can choose any uint32 value as <tt>requester_rank</tt> except -1.
</t-->
<t indent = "0">
<tt>protocol_param</tt>: ECDH-PSI protocol configurations supported by the requester.</t>

<section anchor = "hk-request-protocol"><!-- protocol_proposal 3.2.1.1-->
<name>Protocol Proposal</name>
<t indent = "0">
The <tt>ProtocolProposal</tt> message describes ECDH-PSI protocol parameters supported by the requester.
</t>

<t indent = "0">Structure of this message:</t>
<sourcecode>
enum {
  null (0),
  P256_XMD_SHA256_SSWU_NU_ (1),
  P384_XMD_SHA384_SSWU_NU_ (2),
  P521_XMD_SHA512_SSWU_NU_ (3),
  curve25519_XMD_SHA512_ELL2_NU_ (4),
  (255)
} HashToCurveSuite;

enum { compressed (0), uncompressed  (1), (255) } PointOctetFormat;

enum {
  no_truncation (0),
  128_bit_truncation (1),
  192_bit_truncation (2),
  (255)
} TruncationOption;

struct {
  HashToCurveSuite    suites&lt;1..255&gt;;
  PointOctetFormat    point_octet_formats&lt;1..255&gt;;
  TruncationOption    truncation_options&lt;1..255&gt;;
} ProtocolProposal;
</sourcecode>

<!--t indent = "0">
supported_versions: The list of supported versions of <tt>ProtocolProposal</tt>.
</t-->
<t indent = "0">
<tt>suites</tt>: The list of supported <tt>HashToCurveSuite</tt> in order of requester's preference.
</t>

<t>
The suites defined here are slightly different from <xref target = "RFC9380"/>.
To be compatible with the representation language of <xref target = "RFC8446"/> where enumerate types are defined by C identifiers, the colons (":") are replaced with underscores ("_"), and hyphens ("-") in hash functions are removed (e.g., "SHA-256" is replaced by "SHA256").
</t>

<t indent = "0">
Different suites use different DST strings as required by <xref target = "RFC9380"/>.
In particular, ECDH-PSI uses "ECDH-PSI-V&lt;xx&gt;-&lt;suites&gt;" as its DST, where &lt;xx&gt; is a two-digit hexadecimal number indicating the current protocol version as specified by the <tt>version</tt> field of <tt>HandshakeRequest</tt>, and &lt;suites&gt; is the ASCII string representation of the currently adopted suite as defined by <xref target = "RFC9380"/>.
As an example, when both participants agree to use the suite for P256 curve, the corresponding DST is "ECDH-PSI-V01-P256_XMD_SHA256_SSWU_NU_".
</t>



<!--Each ciphersuite definition contains a elliptic curve group, a hash algorithm and a <tt>hash_to_curve</tt> method as listed in <xref target="cs_list"/>.-->

<t indent = "0">
<tt>point_octet_formats</tt>: The list of octet string formats representing EC points, in the order of requester's preference.
This field enables the participants to weigh the tradeoffs between the costs of communication and computation as discussed by <xref target = "ic_format"/>.

<ul spacing="normal" bare="false" empty="false" indent="2">
<li>
For the curves defined in <xref target = "FIPS186-4"/>, the <tt>PointOctetFormat</tt> values refer to the corresponding compressed/uncompressed formats documented by <xref target="ECDSA"/>.
</li>
<li>
Points on Curve25519 are always encoded following the description by Section 5 of <xref target = "RFC7748"/> as 32 byte strings.
Unlike the other curves, the scalar multiplication of curve25519 only relies on one 32-byte coordinate without the cost of decompressing to the (x,y)-coordinate representation, which eliminates the need of making a tradeoff.
</li>
</ul>
</t>
<t indent = "0">
<tt>truncation_options</tt>:
Whether the requester supports truncation for data transferred in the second round.
The options are listed in the requester's order of preference, where <tt>no_truncation</tt> <bcp14>MUST</bcp14> be included.
The truncation could decrease the costs of data transmission and storage, and even accelerate the computation process of intersection, at the expense of a (negligible) false-positive rate.
</t>
<t>
In this document, only truncation options of 128 and 192-bit are allowed, with a restriction that the total number of data items owned by both participants <bcp14>SHOULD</bcp14> be no more than 2^40, ensuring that the probability of collision is smaller than 2^-48 when 128 bits are truncated. See <xref target = "sc_data_truncation"/> for a detailed discussion.
The requester <bcp14>MUST</bcp14> set this field to a single <tt>no_truncation</tt> option when its data set size has already been equal or larger than 2^40.
</t>
<t>
The truncation process utilizes Key Derivation Functions (KDFs) as many key-exchange protocols that use shared secrets to derive shorter strings which can be seen as uniformly distributed cryptographic keys (e.g., <xref target = "RFC8446"/><xref target = "RFC9382"/>).
In this document, the KDFs are instantiated by Hashed Message Authentication Code (HMAC) <xref target = "RFC2104"/>, along with HMAC-based KDF (HKDF)<xref target = "RFC5869"/>, and the hash function included in hash_to_curve suite.
</t>
<t>
Following <xref target = "RFC5869"/>, a KDF function <tt>kdf()</tt> takes a input keying material <tt>ikm</tt>, a salt value <tt>salt</tt>, an application specific information <tt>info</tt> and output length <tt>len</tt> as its inputs.
Let <tt>mask_data</tt> be the string representation of a jointly masked point, a participant <bcp14>SHOULD</bcp14> truncate <tt>mask_data</tt> with:
</t>
<artwork name="" type="" align="left" alt="">
truncated_mask_data = kdf(mask_data, nil, "ECDH-PSI", truncation_len)
</artwork>
<t>
In particular, the KDF takes <tt>mask_data</tt> as the input keying material and <tt>truncation_len</tt> of 128 or 192 depending on the selected truncation option.
It does not take a salt value, uses ASCII string "ECDH-PSI" as the application specification information, and outputs the derived string as truncation result.
When "ECDH-PSI" string is taken as the input for <tt>kdf</tt>, the terminating null byte <bcp14>SHOULD</bcp14> not be included.
</t>

</section><!-- protocol_proposal 3.2.1.1-->


</section><!-- HandshakeRequest 3.2.1-->

<section anchor="hk-response"><!-- HandshakeResponse 3.2.2-->
<name>HandshakeResponse</name>

<t indent = "0">
The responder sends <tt>HandshakeResponse</tt> to reply to a <tt>HandshakeRequest</tt> message.
It includes selected parameters and the size of responder's dataset.
</t>
<t indent = "0">
Structure of this message:</t>
<sourcecode>

enum {
  success(0),
  generic_error         (0x01),
  unsupported_version   (0x02)
  invalid_request       (0x03),
  out_of_resource       (0x04),
  unsupported_parameter (0x05),
  (0xFF)
} HandshakeStatus;

struct {
  HandshakeStatus status;
  uint64 record_num;
  ProtocolResult protocol_param;
} HandshakeResponse;
</sourcecode>

<t indent = "0">
<tt>status</tt>: Indicating the status of handshake. The meanings of error statuses are listed as follows:
</t>
<list style = "symbols">
<t>
<tt>generic_error</tt>: The error cannot be categorized to the rest error statuses defined by <tt>HandshakeStatus</tt>.</t>
<t><tt>unsupported_version</tt>: The responder does not support the ECDH-PSI protocol version given by <tt>version</tt>.</t>
<t><tt>invalid_request</tt>: The responder cannot parse the request correctly.
The message may be in wrong format and cannot be parsed as a normal <tt>HandshakeRequest</tt> message.
</t>
<t><tt>out_of_resource</tt>: The responder does not have enough resource to handle the ECDH-PSI process with the parameters and options provided by the requester.</t>
<t><tt>unsupported_parameter</tt>: The responder rejects all options proposed by one of the suggested option lists included in <tt>HandshakeRequest</tt>.</t>
</list>
<t>
The responder <bcp14>MUST</bcp14> ignore all options or parameters that it cannot recognize when parsing the <tt>HandshakeRequest</tt> message.
If one of the suggested option lists is filled with unrecognized parameters, it <bcp14>SHOULD</bcp14> reply with a <tt>HandshakeResponse</tt> carrying <tt>unsupported_parameter</tt>.
</t>

<t>
Upon receiving a <tt>HandshakeResponse</tt> message without <tt>success</tt> status, the requester <bcp14>MUST</bcp14> ignore the other fields included in this message and terminate the session.
</t>

<t indent = "0" >
<tt>item_num</tt>: The size of responder's dataset.</t>

<t indent = "0">
<tt>protocol_param</tt>: The protocol parameter selected by the responder, including the hash_to_curve suite, EC point string format and truncation option.
</t>

<section anchor = "hk-result-protocol"><!-- protocol_result 3.2.2.1 -->
<name>Protocol Result</name>

<t indent = "0">
The structure of <tt>ProtocolResult</tt> is defined as follows:
</t>

<sourcecode>
struct {
  HashToCurveSuite    suite;
  PointOctetFormat    point_octet_format;
  TruncationOption    truncation_option;
} ProtocolResult;
</sourcecode>

<t indent = "0">
<tt>suite</tt>: The hash_to_curve suite selected by the responder.</t>

<t indent = "0" >
<tt>point_octet_format</tt>: The format of EC point octet string chosen by the responder.
</t>

<t indent = "0">
<tt>truncation_option</tt>: The truncation option selected by the responder.
The responder <bcp14>SHOULD</bcp14> consider the sum of both participants' dataset sizes.
If the sum is larger than 2^40, truncation <bcp14>MUST</bcp14> not be used, which means the responder <bcp14>MUST</bcp14> set this field to <tt>no_truncation</tt>.
</t>

<t indent = "0">
When deciding the fields of <tt>ProtocolResult</tt>, the responder <bcp14>SHOULD</bcp14> consider the requester's preference.
That is to say, if multiple values of a list are acceptable for the responder, it <bcp14>SHOULD</bcp14> choose the topmost one.
</t>
</section>

</section><!-- HandshakeResponse 3.2.2 -->

<section anchor = "protocol_more_suite">
<name>Support More hash_to_curve Suites</name>
<t>
Participants can negotiate hash_to_curve suites besides the ones listed by <xref target = "hk-request-protocol"/>.
They can use other suites defined by <xref target = "RFC9380"/>, or use a self-defined suite following the syntax and convention given by Section 8.9 and 8.10 of <xref target = "RFC9380"/>.
</t>
<t> As an example, this document next defines a hash_to_curve suite for the ShangMi(SM) curve and cryptography algorithms, which have been accepted by international standards such as <xref target = "ISO-SM2"/>, <xref target = "ISO-SM3"/> and <xref target = "RFC8998"/>.
However, if the participants decide to use elliptic curve parameter with security level less than 128 bit, or a curve over an extension field, they <bcp14>MUST</bcp14> evaluate the security of such parameter carefully as discussed by <xref target = "sc"/>.
</t>
<t>
The new suite, denoted by curveSM2_XMD_SM3_SSWU_RO, encodes data to points on the so-called curveSM2<xref target="GBT.32918.5-2017" format="default" sectionFormat="of" derivedContent="GBT.32918.5-2017"/> with SM3 hash algorithm<xref target = "GBT.32905-2016"/>, and reuses the expand_message_xmd and Simplified Shallue-van de Woestijne-Ulas (SSWU) methods for message expansion and mapping.
</t>

<t>
In particular, curveSM2_XMD_SM3_SSWU_RO_ is defined as follows:</t>

 <ul spacing="normal" bare="false" empty="false" indent="3" >
  <li >encoding type: hash_to_curve</li>
  <li>
    <t indent="0" >E: y^2 = x^3 + A * x + B, where
    </t>
    <ul spacing="normal" bare="false" empty="false" indent="3">
      <li >A = -3</li>
      <li >B = 0x28e9fa9e9d9f5e344d5a9e4bcf6509a7f39789f515ab8f92ddbcbd414d940e93</li>
    </ul>
  </li>
  <li>p: 2^256-2^224-2^96+2^64-1</li>
  <li>r: 0xfffffffeffffffffffffffffffffffff7203df6b21c6052b53bbf40939d54123</li>
  <li>m: 1</li>
  <li>k: 128</li>
  <li>expand_message: expand_message_xmd (Section 5.3.1 of <xref target = "RFC9380"/>)</li>
  <li>H: SM3</li>
  <li>L: 48</li>
  <li>f: SSWU method (Section 6.6.2 of of <xref target = "RFC9380"/>)</li>
  <li>Z: -9</li>
  <li>h_eff: 1</li>
</ul>
<t>
The value Z is calculated by the sage script given by Appendix H.2 of <xref target = "RFC9380"/> with the p, A and B parameters of curveSM2.
</t>
<t>
The participants <bcp14>SHOULD</bcp14> agree on the meaning of <tt>HashToCurveSuite</tt> values.
In this document, suite curveSM2_XMD_SM3_SSWU_RO_ is identified as follows:
<sourcecode>
enum {
  null                              (0),
  ... // (1) to (4) follow section 3.2.1.1
  curveSM2_XMD_SM3_SSWU_RO_         (5),
  ... // other hash_to_curve suites
  (255)
} HashToCurveSuite;
</sourcecode>
</t>
</section>


</section><!-- Handshake 3.2 -->

<section anchor="data_exchange"><!-- Evaluation 3.3 -->
<name>Data Exchange</name>

<t indent = "0">
In the data exchange phase, masked EC points are exchanged as <tt>EcdhPsiBatch</tt> messages.
The participants <bcp14>MUST</bcp14> generate fresh ECDH-PSI keys after the handshake phase, and use the newly generated keys to mask the EC points.
The ECDH-PSI keys <bcp14>SHOULD</bcp14> be removed immediately after the data exchange phase in order to prevent leakage or being reused by other applications by coincidence.
</t>

<t>
This phase consists of two rounds.
In the first round, both participants send <tt>EcdhPsiBatch</tt> messages carrying locally masked EC points, where the requester sends the first one.
In the second round, <tt>EcdhPsiBatch</tt> messages carrying jointly masked EC points are sent.
If the requester sets <tt>output_mode</tt> field by <tt>1</tt>, then only the responder sends an <tt>EcdhPsiBatch</tt> message, otherwise both participant sends <tt>EcdhPsiBatch</tt> messages as in the first round.
</t>

<t>
If the participants have negotiated a <tt>truncation_option</tt> of 128 or 192 bit in the handshake phase, such option <bcp14>MUST NOT</bcp14> be used in the first round, since truncated strings cannot be recovered to EC points, which makes the second mask operation completely infeasible.

<!--
In each round, a participant may send or receive multiple <tt>EcdhPsiBatch</tt> messages.
Upon receiving a <tt>EcdhPsiBatch</tt> and handling the data properly, the participant <bcp14>SHOULD</bcp14> respond with a <tt>EcdhPsiBatchResponse</tt> message,
indicating its partner that it is ready to receive the next <tt>EcdhPsiBatch</tt> message.
-->
</t>

<section anchor = "data_exchange_batch">
<name>EcdhPsiBatch</name>
<t indent = "0" pn = "section-3.3.1-1">
The structure of <tt>EcdhPsiBatch</tt> is defined as follows:</t>

<sourcecode pn = "section-3.3.1-2">
struct {
  uint64 index;
  opaque encoded_point[encoded_point_length];
} ECPointOctet;

struct {
  uint32        batch_type;
  uint64        batch_count;
  ECPointOctet  encoded_points&lt;1..2^64-1&gt;;
} EcdhPsiBatch;
</sourcecode>

<t indent = "0">
<tt>batch_type</tt>: This field indicates the status of current batch.
<ul>
<li>0: Error occurs, which means that the current ECDH-PSI session <bcp14>MUST</bcp14> be terminated immediately.</li>
<li>1: The data included in the current batch are only masked by the owner's private key.</li>
<li>2: The data has been jointly masked with both participants' private keys. </li>
</ul>
The participant <bcp14>SHOULD</bcp14> check this field first before parsing <tt>encoded_points</tt> field.
If <tt>batch_type</tt> is 0, or the value is not the same as expected, the receiver <bcp14>MUST</bcp14> discard all intermediate results, remove the ECDH-PSI key, and terminate the session.
</t>

<t indent = "0">
<tt>batch_count</tt>: Number of EC points included in the current <tt>EcdhPsiBatch</tt> message.
The receiver <bcp14>SHOULD</bcp14> also check that the value of this field is the same as expected and matches the <tt>data</tt> field.
It <bcp14>MUST</bcp14> terminate the session if it is not the case, since an attacker may send more points than expected so as to obtain some privilege of breaking the major privacy goal of ECDH-PSI.
See <xref target="sc_static_ecdh_oracle"/> for more detail.
</t>

<t indent = "0">
<tt>encoded_points</tt>:
This field carries multiple EC points with <tt>ECPointOctet</tt>, which number is specified by the <tt>batch_count</tt> field.
Each <tt>ECPointOctet</tt> structure includes an unique <tt>index</tt> allocated by the owner of the corresponding original data, and the octet string <tt>encoded_point</tt> encoding an EC point.
The length of <tt>encoded_point</tt>, which is <tt>encoded_point_length</tt>, is determined by the hash_to_curve suite, the compression option and the truncation option.
</t>

<t>The purpose of <tt>index</tt> is to associate the original data item with the (jointly)-masked EC points, such that the participant can match its original dataset with the intersection of masked datasets.
The values of <tt>index</tt> are generated by the owner of data so as to identify each data record uniquely.
When masking the data from its partner, a participant <bcp14>MUST</bcp14> reserve the <tt>index</tt> for every record.
<xref target="app_con_index"/> gives more discussions on the implementation and maintenance of such indexes.
Furthermore, <xref target="sc_side_channel"/> discusses the risk of side channels raised by indexes and describes a common countermeasure to mitigate such threats.
</t>

<t>
The content of <tt>encoded_point</tt> strings are treated differently in round 1 and 2.
<ul>
<li>Round 1: The sender of <tt>EcdhPsiBatch</tt> <bcp14>SHOULD</bcp14> encode EC points to octet strings according to <tt>point_octet_format</tt> negotiated in the handshake phase.
The receiver <bcp14>SHOULD</bcp14> decode the octet strings to EC points accordingly.
It <bcp14>MUST</bcp14> check that the EC points are on the curve in order to prevent the so-called small group attacks.
After masking the received set of EC points with its private key, the participant <bcp14>SHOULD</bcp14> save the jointly masked points if it is allowed to output the intersection.
</li>
<li>Round 2:
The sender <bcp14>SHOULD</bcp14> encode the points with the negotiated <tt>point_octet_format</tt>, and truncate the string if <tt>truncation_option</tt> is set.
The receiver <bcp14>SHOULD</bcp14> treat the contents as octet strings rather than decode them to EC points, as such strings are enough for computing the intersection.
Furthermore, if <tt>truncation_option</tt> is set, the receiver <bcp14>SHOULD</bcp14> also truncate the jointly masked dataset stored by round 1 with the same truncation method before computing the intersection.
</li>
</ul>
Especially, to convert the original data records to EC points over the curve, the participant <bcp14>SHOULD</bcp14> export <tt>ekm</tt> from the current TLS session as stated by <xref target = "RFC8446"/><xref target = "RFC9266"/>, and map record <tt>data</tt> to EC point <tt>P</tt> with <tt>P=hash_to_curve(ekm||data)</tt>.
</t>


<!--The EC point data to be transferred in the current message, which number is specified by the <tt>batch_count</tt> field.
The format of each EC point octet string is determined by the selected EC group, point octet string format and the truncation option.
-->
</section><!-- 3.3.1 EcdhPsiBatch-->

</section><!-- Evaluation 3.3 -->
</section><!-- Protocol 3 -->




<section anchor="ic"><name>Implementation Considerations</name>

<section anchor="ic_format"><!-- EC Point Format 3.3.1 -->
<name>The Representation of EC Point</name>
<!--t indent = "0">
The representation of SM2 curve point <bcp14>SHOULD</bcp14> follow <xref target="GBT-32918.1-2016"/>, which can be one of "uncompressed", "compressed" or "hybrid".
</t>
<t indent = "2">
- Uncompressed: The representation is defined by 0x04||X||Y, where X (resp. Y) is the binary representation of the x (resp. y) coordinate which has a length of 32 bytes.
</t>
<t indent = "2">
- Compressed: If the least significant bit of y coordinate is 0, the representation is defined by 0x02||X.
Otherwise, the representation is 0x03||X.
</t>
<t indent = "2">
- Hybrid: The representation is 0x06||X||Y if the least significant bit of y coordinate is 0, and 0x07||X||Y if the bit is 1.
</t>
<t indent = "0">
The receiver of such a representation can use the first byte to identify its type and decode the representation following the type.
</t>

<t indent = "0">
For curve25519, the representation of EC point is the binary representation of the x coordinate, which is sufficient for <tt>scalar_mul</tt> <xref target="CZZDL24"/>.
</t-->
<t indent = "0">
When deciding the point encoding format for the elliptic curves except for curve25519, the participants should consider the aspects of bandwidth, storage and computation comprehensively.
Compressed point format could decrease the costs of transmission and storage,
but it also needs computation resources to "decompress" the point.
Uncompressed format requires more storage spaces and needs more time to transmit,
but the participant can perform scalar multiplications without extra effort to recover the points.
</t>

<t indent = "0">
For example, when both parties are deployed in the same data center and linked with a high-bandwidth local area network (LAN), they can choose to use the uncompressed format to achieve better performance.
</t>

<t indent = "0">
As another example, the parties may be deployed in geographically separated data centers connected with low bandwidth wide area network (WAN), and equipped with high-end computation acceleration devices such as Graphics Processing Units (GPUs). In this case, the computation resource may not be the bottleneck, and the participants can choose the compressed format to minimize the cost of data transmission.
</t>
</section>


<section anchor = "app_con_index">
<name>The Management of Index</name>
<t indent = "0">
A <bcp14>RECOMMENDED</bcp14> method of maintaining indexes is storing the records with a database table and using the row numbers or prime keys as indexes.
The intersection result can be matched with original data items by a simple join operation.
The participant could also design a different indexing mechanism on its own, as long as the index can be used to identify a record uniquely.
</t>
<t>
This document uses explicit indexes to identify data items rather than treating the order of records as "implicit" indexes.
Compared with the implicit counterpart, explicit indexes can be efficiently created and maintained by modern databases, and do not require the participants to implement extra logic to preserve the order of records.
</t>
<t>
After masking the EC points from its partner, a participant <bcp14>MUST</bcp14> send the jointly masked data with correct indexes.
To achieve this, it keeps the indexes of each data items received in the first round, masks the records with its private key, and associates the masked records with the same indexes.
These operations can also be implemented easily with database operations by viewing the received records and masked records as columns in the same table, which enables them to be linked naturally via the prime keys.
</t>
<!--t indent = "0">
The protocol flow of ECDH-PSI calculates the intersection of doubly-evaluated points, and requires the participant to map the points back to the original data in order to output correct results.
That is, a participant <bcp14>SHOULD</bcp14> create a mapping table describing the relationship between original data items and doubly-evaluated points.
</t>
<t>
An example of mapping method is described as follows:
<list style="numbers" type="1" >
  <t>The participant records the pairs of original data items and corresponding evaluated points.
  </t>
  <t>In the doubly-evaluation process, its partner keeps the order of points during data transmission and evaluation,
  such that the participant can map original data to the correct doubly-evaluated point.
  </t>
  <t>The participant maps the intersection of evaluated data to the original data, and outputs the intersection result.
  </t>
</list>
</t-->
</section>

<section anchor = "ac_large_record"><name>Large Record Size</name>
<t>
The <tt>EcdhPsiBatch</tt> message can be very large.
For example, if the dataset contains 2^30 records, the size of encoded EC points included in a single <tt>EcdhPsiBatch</tt> message can be over 60 GB.
Participants of ECDH-PSI <bcp14>SHOULD</bcp14> take great care when implementing the underlying communication channel, and guarantee that there are enough buffer or storage space for sending or receiving such messages.
</t>

<t>
The methods of sending and handling large messages are beyond the scope of this document.
</t>
</section>

</section> <!-- Cryptographic 6.3-->

<section anchor = "sc">
<name>Security Considerations</name>
<t>
For PSI protocols, the foremost security goal is ensuring that the private data elements (i.e., records not in the intersection) are not revealed.
Neither a protocol partner nor an external attacker can obtain such private elements with the protocol.
</t>

<t>
This section describes the threat model related to ECDH-PSI, discusses the threats of key reuse,
MITM attack, replay attack and side channel, and finally gives probability bounds related to the truncation mechanism.
</t>

<section anchor = "sc_threat_model"><name>Threat Model</name>
<t>
Traditionally, ECDH-PSI protocols are considered secure under the so-called semi-honest setting, where both participants will follow the protocol specification, but try to guess each others' private inputs by observing the received messages.
</t>

<t>
This document considers an extended setting of malicious attackers.
In such setting, ECDH-PSI cannot guarantee that the participants always output correct results, as a malicious participant can send arbitrary messages that produce wrong results.
However, it is excepted that ECDH-PSI can somehow preserve the main security goal of data privacy even under such  a setting.
</t>

<t>
In particular, the threat model considers external attackers who have the privilege to access the communication channel between the participants, and internal attackers who act a participant of the protocol.
</t>

<t>
In this document, most external attackers are excluded by TLS protocol <xref target="RFC8446"/> with mutual authentication, where the participants are authentcated mutually, and the messages are encrypted and authenticated.
With the protection of TLS, the external attacker will not be able to inject, replay, truncate or manipulate messages transferred by the channel.
Any malicious behavior will be detected immediately by TLS, and the relevant data will be discarded without passing to the application layer.
However, TLS alone cannot prevent the Man-In-The-Middle (MITM) attack performed by a malicious node who concurrently runs two sessions and forwards messages from one session to another, which is discussed by <xref target = "sc_man_in_the_middle"/>.
</t>


<t>
Malicious internal attackers may send arbitrary messages during the protocol execution.
That is to say, it may sends:
</t>
<ul>
<li>Malformed handshake messages.</li>
<li>Malformed masked points.</li>
<li>Malformed jointly masked points.</li>
</ul>

<t>
In fact, malformed handshake message or jointly masked points may eliminate the protocol execution due to incorrect message syntaxes or mislead the victim to output wrong result, which will not harm the major security goal of data privacy.
However, the attacker can use malformed masked points to construct a static ECDH oracle, as the victim will always mask those points with its own private key and send the results back.
That is to say, if <tt>P1</tt> is a malformed masked EC point sent by the attacker and <tt>sk</tt> is the victim's secret key used in ECDH-PSI, the attacker will get <tt>P1^sk</tt>.
Once the attacker obtains some advantages with the querying process and calculates <tt>sk</tt>, it can immediately calculate <tt>sk^-1</tt> and use it to "de-mask" any data masked by the victim.
</t>

</section>

<section anchor = "sc_static_ecdh_oracle"><name>Static ECDH Oracle</name>
<t>
In this section, we analysis the risk of static ECDH oracle as described by <xref target = "sc_threat_model"/>, where each ECDH-PSI session can be utilized as an oracle for the ECDH-PSI key used in the current session.
The attacker can declare that the size of its dataset is very large, and query the oracle as many times as it could.
However, once the session ends, the victim will delete the ECDH-PSI key and use a freshly generated key for new sessions, which means that the attacker will query different oracle instances in different sessions.
</t>

<t>
In general, let <tt>v</tt> be the maximum time of querying an oracle instance, the static ECDH oracle may decrease the security level of elliptic curve by about <tt>log(2,v)/2</tt> bits.
The problem of static ECDH oracle has been studied extensively in a series of literatures including <xref target = "BG04"/><xref target = "Gra10"/><xref target = "MU10"/><xref target = "JV13"/>.
</t>

<t>
For the curves employed by this document, the most efficient attack strategy is still the one described by <xref target = "BG04"/>.
In particular, let <tt>u</tt> and <tt>v</tt> be a pair of integers satisfying <tt>u*v=r-1</tt>, the <xref target = "BG04"/> attack requires the attacker to query the oracle <tt>v</tt> times and uses
</t>

<artwork>2(sqrt(u)+sqrt(v))=2(sqrt((r-1)/v)+sqrt(v))
</artwork>

<t>
scalar multiplications to calculate the secret key.
Take the relationship that the security level of an elliptic curve group can be approximately seen as <tt>n=log(2,sqrt(r))</tt>, the number of scalar multiplications can be seen as <tt>2(2^n/sqrt(v)+sqrt(v))</tt>.
However, in ECDH-PSI, <tt>v</tt> is limited by the maximum number of elements holding by one of the participants, which is <tt>2^64</tt> since the parameter of <tt>batch_count</tt> is carried by an <tt>uint64</tt>.
That is to say, for all the group parameters employed by this document, <tt>2^n/sqrt(v)</tt> will be much larger than <tt>sqrt(v)</tt>,
and the attacker needs to perform <tt>2^n/(sqrt(v)/2)</tt> multiplications, which approximately means the security level will be decreased by <tt>log(2,sqrt(v)/2)=log(2,v)/2-1</tt> bits.
For the maximum value of <tt>v</tt>, which is <tt>2^64</tt>, the conclusion indicates that the security level will be decreased by 31 bits.
</t>

<t>
For the curves employed by this document, the decrease of 31 bits is acceptable, as the minimum security level is 128 bit, which will be decreased to 128 - 31 = 97 bits.
Currently, there dose not exist any evidence that an elliptic curve with security level of 97 bits is vulnerable to practical attacks.
Furthermore, this document does not use elliptic curves defined over extension fields which may be vulnerable to the more efficient attacks proposed by <xref target = "Gra10"/> and <xref target = "JV13"/>.
</t>

<t>
<xref target = "MU10"/> describes another attack by combing static ECDH oracles with the notorious small-group attack.
To prevent such attacks, the receiver of a set of EC points <bcp14>MUST</bcp14> checks that every point is on the curve, as specified by <xref target = "data_exchange"/>.
</t>

</section>

<section anchor = "sc_key_reuse"><name>Key Reuse</name>
<t>
This section discusses the risks of reusing ECDH-PSI key across different sessions.
In particular, reusing an ECDH-PSI key may decrease the security level of the elliptic curve based on the discussion presented by <xref target = "sc_static_ecdh_oracle"/>, or be utilized by a semi-honest attacker to reveal information related with different protocol runs.
</t>

<t>
As shown by <xref target = "sc_static_ecdh_oracle"/>, the key point of <xref target = "BG04"/> attack strategy is the maximum query number for a single oracle instance.
Reusing ECDH-PSI key will decrease the security level by much more than 31 bits as the allowed number of queries changes to the sum of queries allowed by all instances using the same key.
In the worst case where the sum of queries is <tt>2^(n/2)</tt>, the security level will be decreased by almost a half.
</t>

<t>
If an ECDH-PSI key is reused across sessions, an attacker can participate these sessions as partners and obtain some extra information.
For instance, the victim V may provide two different sets (denoted by <tt>set_0</tt> and <tt>set_1</tt>) in two different sessions, where the elements are masked by the same secret key <tt>sk</tt> as <tt>set_0^sk</tt> and <tt>set_1^sk</tt>.
Then, the attacker who joins both the sessions can calculate <tt>intersect(set_0^sk,set_1^sk)</tt> and learn the size of <tt>intersect(set_0,set_1)</tt>.
Despite that the attacker still cannot recover the original set <tt>set_0</tt> or <tt>set_1</tt>, it indeed learns extra information beyond the original output of PSI even in the semi-honest setting.
</t>


</section>

<section anchor = "sc_man_in_the_middle"><name>Man-In-The-Middle Attack</name>
<t>
MITM attack in ECDH-PSI refers to the case that the adversary acts as an agent who transmits messages between two honest participants.
If the attacker transmits messages faithfully, it finally learns the cardinality of the intersection as it obtains the jointly masked datasets of both participants.
However, as stated above, the attacker cannot break the privacy of original data items as it cannot obtain the ECDH-PSI keys with such attacks.
</t>



<t>
In this document, such attacks are avoided by the TLS binding mechanism <xref target = "RFC9266"/>.
In particular, the particpants use the "tls_exporter" channel binding type to export EKM strings from the TLS sessions, and concatenate the EKM string with the original data item as input to the <tt>hash_to_curve</tt> function as specified by <xref target="data_exchange"/>.
</t>

<t>
If the malicious adversary <tt>M</tt> performs MITM attacks against participants <tt>A</tt> and <tt>B</tt>, it will establish two different TLS sessions denoted by <tt>s_a</tt> and <tt>s_b</tt>.
Then, <tt>A</tt> will export EKM <tt>ekm_a</tt> from TLS session <tt>s_a</tt>, and <tt>B</tt> will export a different <tt>ekm_b</tt> from <tt>s_b</tt>, which means that the same data element <tt>data</tt> will be mapped to different points on the curve with <tt>P_A=hash_to_curve(ekm_a||data)</tt> and <tt>P_B=hash_to_curve(=ekm_b||data)</tt>.
The PSI protocol will finally fail since the same data item cannot be mapped to the same point on the curve, but the attacker also cannot learn the size of the intersection, which provides more privacy guarantee beyond the secrecy of original data items.
</t>

</section>

<section anchor = "sc_replay"><name>Replay Attack</name>
<t>
In <xref target = "CY20"/>, Cui and Yu design a new attack for concurrent runs of ECDH-PSI sessions in the malicious setting.
In this attack, the attacker establishes two sessions with the same victim who uses two different data sets <tt>set_1</tt> and <tt>set_2</tt> in different sessions, and finally learns the size of <tt>intersect(set_1,set_2)</tt>.
</t>

<t>
Let <tt>sk_1</tt> and <tt>sk_2</tt> denote the ECDH-PSI keys that the victim uses in different sessions, the attacker <tt>M</tt> performs the attack to <tt>V</tt> as follows (also refer to <xref target="fig-replay"/>):
</t>

<ul>
<li>
Step 1: <tt>M</tt> initiates the first session with <tt>V</tt>, where <tt>V</tt> maps all elements of <tt>set_1</tt> to points as set <tt>pset_1</tt>, masks them with <tt>sk_1</tt>, and sends <tt>mset_1=pset_1^sk_1</tt>.</li>
<li>
Step 2: <tt>M</tt> initiates another session with <tt>V</tt>, and obtains <tt>mset_2=pset_2^sk_2</tt> as in Step 1.
</li>
<li>
Step 3: The attacker chooses <tt>r_1</tt> and <tt>r_2</tt>, and masks the sets received in Step 1 and 2 with <tt>rset_1=mset_1^r_1</tt> and <tt>rset_2=mset_2^r2</tt>.
</li>
<li>
Step 4: <tt>M</tt> "reflects" the set received in session 1 to <tt>V</tt> in session 2 by sending <tt>rset_1</tt> to <tt>V</tt> in the second session.
Then the victim masks <tt>rset_1</tt> with its ECDH-PSI key for session 2 and sends <tt>dset_2=rset_1^sk_2</tt> to the attacker.
</li>
<li>
Step 5: As in Step 4, the attacker sends <tt>rset_2</tt> to the victim in session 1, and receives <tt>dset_1=rset_2^sk_1</tt>.
</li>
<li>
Step 6: Upon receiving <tt>dset_1</tt> and <tt>dset_2</tt>, the attacker de-randomizes the sets with <tt>r_2^-1</tt> and <tt>r_1^-1</tt> respectively, and obtains:
</li>
<li>
Step 7: <tt>M</tt> calculates the intersection of <tt>vset_1</tt> and <tt>vset_2</tt>, which has the same cardinality with the intersection of <tt>set_1</tt> and <tt>set_2</tt>.
</li>
</ul>

<artwork>
vset_1=dset_1^(r_2^-1)=pset_1^sk_1^sk_2
vset_2=dset_2^(r_1^-1)=pset_2^sk_2^sk_1
</artwork>



<figure title="The replay attack against ECDH-PSI" anchor="fig-replay">
<artwork>
<![CDATA[

                   V                                     M
      -----------------------------------------------------------------
                   |                                     |
s1:       pset_1=hash_to_curve(set_1)                    |
          mset_1=pset_1^sk_1                             |
                   |               mset_1                |
                   | ----------------------------------> |
                   |                                     |
s2:       pset_2=hash_to_curve(set_2)                    |
          mset_2=pset_2^sk_2                             |
                   |               mset_2                |
                   | ----------------------------------> |
                   |                                     |
                   |                             choose r_1 and r_2
                   |                             rset_1=mset_1^r_1
                   |                             rset_2=mset_2^r_2
                   |                                     |
s2:                |               rset_1                |
                   | <---------------------------------- |
          dset_2=rset_1^sk_2                             |
                   |               dset_2                |
                   | ----------------------------------> |
                   |                                     |
s1:                |               rset_2                |
                   | <---------------------------------- |
          dset_1=rset_2^sk_1                             |
                   |               dset_1                |
                   | ----------------------------------> |
                   |                                     |
                   |                           vset_1=dset_2^(r_1^-1)
                   |                           vset_2=dset_1^(r_2^-1)
                   |                                     |
                   |                    calculate |intersect(vset_1,vset_2)|
                   |                                     |

]]>
</artwork></figure>

<t>
The replay attack can also be mitgated with TLS channel binding mechanism.
In particular, if the participants adopt TLS channel binding as specified by <xref target="data_exchange"/>, then, in steps 1 and 2 of the replay attack, the victim will extract different EKMs and use them to calculate <tt>pset_1</tt> and <tt>pset_2</tt> respectively.
That is to say, even <tt>set_1</tt> and <tt>set_2</tt> contain some common elements, they will be mapped to different points in <tt>pset_1</tt> and <tt>pset_2</tt> as the EKMs are different, which finally fails the attacker in step 7 as overlapped elements are mapped to different points in <tt>vset_1</tt> and <tt>vset_2</tt>.
</t>

</section>

<section anchor = "sc_side_channel"><name>Side Channel</name>
<t>
In some circumstances, the order of elements and data indexes can be utilized by a semi-honest attacker as a side-channel which leaks information about the original dataset.
When two participants A and B execute ECDH-PSI and output the intersection result, one party (say, B) also knows where these common elements appear in A's list and their indexes, such orders and indexes can be used to infer the orders of inserting those elements to a database table.
</t>

<t>
A generic method to avoid such side-channels is shuffling the order of elements, as well as the indexes, before they are sent to the partner.
However, the shuffling operation may be costly or even practically infeasible when the size of dataset is very large.
The participant <bcp14>SHOULD</bcp14> evaluate the risk of side-channels and use suitable mitigation mechanisms when the risk is unacceptable.
</t>

</section>

<section anchor="sc_data_truncation"><name>Data Truncation </name>
<t>
This section provides a detailed discussion on the truncation mechanism presented in this document.
</t>
<t>
The truncation, undoubtedly, will raise the probability of message collision.
That is, two different data item may be mapped to the same string after the procedures of masking and truncation by coincidence.
The collision may happen across the datasets owned by different participants, which causes a false-positive case that two different records are matched by PSI, or happen in the same dataset.
The later situation may also lead to a false-positive case.
To be more specific, consider a participant A has two different data items data_X and data_Y which are mapped to the same record mask_data_XY.
Its partner, say B, also has record data_X which is mapped to mask_data_XY.
Finally, A outputs both data_X and data_Y as the result of PSI, as it cannot distinguish which one matches the record of mask_data_XY.
</t>
<t>
To avoid such false-positive case, we have to consider the collision probability with respect to the sum number of data items owned by A and B.
Such probability can be computed with the well-known birthday paradox bound.
Let <tt>n</tt> be the number of sampling and <tt>d</tt> be the output space, the probability of collision can be approximately computed with:
</t>
<artwork>
p(n,d)=1-e^(-n(n-1)/2d)
</artwork>

<t>
This document uses two truncation sizes of 128 bit and 192 bit.

For 128-bit truncation, the probabilities of different <tt>n</tt>  and <tt>d=2^128</tt> are calculated as follows:
</t>

<list style = "symbols">
<t>If <tt>n=2^50</tt>, <tt>p(2^50, 2^128) = 2^-29</tt></t>
<t>If <tt>n=2^45</tt>, <tt>p(2^45, 2^128) = 2^-33</tt></t>
<t>If <tt>n=2^41</tt>, <tt>p(2^41, 2^128) = 2^-47</tt></t>
<t>If <tt>n=2^40</tt>, <tt>p(2^40, 2^128) = 2^-49</tt></t>
<t>If <tt>n=2^39</tt>, <tt>p(2^39, 2^128) = 2^-51</tt></t>
</list>


<t>
For 192-bit truncation, the probabilities are listed as follows:
</t>
<list style = "symbols">
<t>If <tt>n=2^50</tt>, <tt>p(2^50, 2^192) = 2^-93</tt></t>
<t>If <tt>n=2^45</tt>, <tt>p(2^45, 2^192) = 2^-103</tt></t>
<t>If <tt>n=2^41</tt>, <tt>p(2^41, 2^192) = 2^-111</tt></t>
<t>If <tt>n=2^40</tt>, <tt>p(2^40, 2^192) = 2^-113</tt></t>
<t>If <tt>n=2^39</tt>, <tt>p(2^39, 2^192) = 2^-115</tt></t>
</list>

<t>
That is, if the number of records is less than 2^40, the probability of false-positive will be smaller than 2^-48 for truncation length of 128 bit, and smaller than 2^-112 for 192 bit.
The participant can also decide the truncation option by calculating the collision probability, and only use truncation when they both agree that the probability is acceptable.
</t>
</section> <!-- Cryptographic 6.3.3-->
</section>

<section anchor = "iana_c">
<name>IANA Considerations</name>
<t>This document may need IANA to allocate hash_to_curve identifiers which may also be used in other applications.</t>
</section>

</middle>

<back>


<references title='Normative References' anchor="sec-normative-references">

<reference anchor="ECDSA" >
  <front>
    <title>Public Key Cryptography for the Financial Services Industry: The Elliptic Curve Digital Signature Algorithm (ECDSA)</title>
    <author >
      <organization>American National Standards Institute</organization>
    </author>
    <date year="2005" month="November"/>
  </front>
  <seriesInfo name="ANSI" value="ANS X9.62-2005"/>
</reference>

<reference anchor="RFC2104" target="https://www.rfc-editor.org/info/rfc2104" quoteTitle="true" derivedAnchor="RFC2104">
<front>
  <title>HMAC: Keyed-Hashing for Message Authentication</title>
  <author fullname="H. Krawczyk" initials="H." surname="Krawczyk"/>
  <author fullname="M. Bellare" initials="M." surname="Bellare"/>
  <author fullname="R. Canetti" initials="R." surname="Canetti"/>
  <date month="February" year="1997"/>
  <abstract>
    <t indent="0">This document describes HMAC, a mechanism for message authentication using cryptographic hash functions. HMAC can be used with any iterative cryptographic hash function, e.g., MD5, SHA-1, in combination with a secret shared key. The cryptographic strength of HMAC depends on the properties of the underlying hash function. This memo provides information for the Internet community. This memo does not specify an Internet standard of any kind</t>
  </abstract>
</front>
<seriesInfo name="RFC" value="2104"/>
<seriesInfo name="DOI" value="10.17487/RFC2104"/>
</reference>

<reference anchor="RFC5869" target="https://www.rfc-editor.org/info/rfc5869" quoteTitle="true" derivedAnchor="RFC5869">
  <front>
    <title>HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</title>
    <author fullname="H. Krawczyk" initials="H." surname="Krawczyk"/>
    <author fullname="P. Eronen" initials="P." surname="Eronen"/>
    <date month="May" year="2010"/>
    <abstract>
      <t indent="0">This document specifies a simple Hashed Message Authentication Code (HMAC)-based key derivation function (HKDF), which can be used as a building block in various protocols and applications. The key derivation function (KDF) is intended to support a wide range of applications and requirements, and is conservative in its use of cryptographic hash functions. This document is not an Internet Standards Track specification; it is published for informational purposes.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="5869"/>
  <seriesInfo name="DOI" value="10.17487/RFC5869"/>
</reference>

<reference anchor="RFC9380">
  <front>
    <title>Hashing to Elliptic Curves</title>
    <author fullname="A. Faz-Hernandez" initials="A." surname="Faz-Hernandez"/>
    <author fullname="S. Scott" initials="S." surname="Scott"/>
    <author fullname="N. Sullivan" initials="N." surname="Sullivan"/>
    <author fullname="R. S. Wahby" initials="R. S." surname="Wahby"/>
    <author fullname="C. A. Wood" initials="C. A." surname="Wood"/>
    <date month="August" year="2023"/>
    <abstract>
      <t>This document specifies a number of algorithms for encoding or
   hashing an arbitrary string to a point on an elliptic curve.  This
   document is a product of the Crypto Forum Research Group (CFRG) in
   the IRTF.</t>
    </abstract>
  </front>
</reference>

<!--reference anchor="GBT-32918.2-2016">
  <front>
    <title>Information security technology  Public key cryptographic algorithm
              SM2 based on elliptic curves  Part 2: Digital signature algorithm</title>
    <author fullname="Standardization Administration of China" initials="" surname="Standardization Administration of China"/>
    <date month="March" year="2017"/>
        <abstract>
      <t> &lt;http://www.gmbz.org.cn/upload/2018-07-24/1532401673138056311.pdf&gt;.</t>
    </abstract>
  </front>
</reference-->

<reference anchor="GBT.32905-2016" target="http://www.gmbz.org.cn/upload/2018-07-24/1532401392982079739.pdf" quoteTitle="true" derivedAnchor="GBT.32905-2016">
  <front>
    <title>Information security technology --- SM3 cryptographic hash algorithm</title>
    <author>
      <organization showOnFrontPage="true">Standardization Administration of China</organization>
    </author>
    <date year="2017" month="March"/>
  </front>
  <seriesInfo name="GB/T" value="32905-2016"/>
</reference>


<!--reference anchor="RFC2119">
  <front>
    <title>Key words for use in RFCs to Indicate Requirement Levels</title>
    <author fullname="S. Bradner" initials="S." surname="Bradner"/>
    <date month="March" year="1997"/>
    <abstract>
      <t>In many standards track documents several words are used to signify the requirements in the specification. These words are often capitalized. This document defines these words as they should be interpreted in IETF documents. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
    </abstract>
  </front>
  <seriesInfo name="BCP" value="14"/>
  <seriesInfo name="RFC" value="2119"/>
  <seriesInfo name="DOI" value="10.17487/RFC2119"/>
</reference-->

<!-- reference anchor="RFC3986">
  <front>
    <title>Uniform Resource Identifier (URI): Generic Syntax</title>
    <author fullname="T. Berners-Lee" initials="T." surname="Berners-Lee"/>
    <author fullname="R. Fielding" initials="R." surname="Fielding"/>
    <author fullname="L. Masinter" initials="L." surname="Masinter"/>
    <date month="January" year="2005"/>
    <abstract>
      <t>A Uniform Resource Identifier (URI) is a compact sequence of characters that identifies an abstract or physical resource. This specification defines the generic URI syntax and a process for resolving URI references that might be in relative form, along with guidelines and security considerations for the use of URIs on the Internet. The URI syntax defines a grammar that is a superset of all valid URIs, allowing an implementation to parse the common components of a URI reference without knowing the scheme-specific requirements of every possible identifier. This specification does not define a generative grammar for URIs; that task is performed by the individual specifications of each URI scheme. [STANDARDS-TRACK]</t>
    </abstract>
  </front>
  <seriesInfo name="STD" value="66"/>
  <seriesInfo name="RFC" value="3986"/>
  <seriesInfo name="DOI" value="10.17487/RFC3986"/>
</reference-->

<!-- reference anchor="RFC4086">
  <front>
    <title>Randomness Requirements for Security</title>
    <author fullname="D. Eastlake 3rd" initials="D." surname="Eastlake 3rd"/>
    <author fullname="J. Schiller" initials="J." surname="Schiller"/>
    <author fullname="S. Crocker" initials="S." surname="Crocker"/>
    <date month="June" year="2005"/>
    <abstract>
      <t>Security systems are built on strong cryptographic algorithms that foil pattern analysis attempts. However, the security of these systems is dependent on generating secret quantities for passwords, cryptographic keys, and similar quantities. The use of pseudo-random processes to generate secret quantities can result in pseudo-security. A sophisticated attacker may find it easier to reproduce the environment that produced the secret quantities and to search the resulting small set of possibilities than to locate the quantities in the whole of the potential number space.</t>
      <t>Choosing random quantities to foil a resourceful and motivated adversary is surprisingly difficult. This document points out many pitfalls in using poor entropy sources or traditional pseudo-random number generation techniques for generating such quantities. It recommends the use of truly random hardware techniques and shows that the existing hardware on many systems can be used for this purpose. It provides suggestions to ameliorate the problem when a hardware solution is not available, and it gives examples of how large such quantities need to be for some applications. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
    </abstract>
  </front>
  <seriesInfo name="BCP" value="106"/>
  <seriesInfo name="RFC" value="4086"/>
  <seriesInfo name="DOI" value="10.17487/RFC4086"/>
</reference -->

<!--reference anchor="RFC4648">
  <front>
    <title>The Base16, Base32, and Base64 Data Encodings</title>
    <author fullname="S. Josefsson" initials="S." surname="Josefsson"/>
    <date month="October" year="2006"/>
    <abstract>
      <t>This document describes the commonly used base 64, base 32, and base 16 encoding schemes. It also discusses the use of line-feeds in encoded data, use of padding in encoded data, use of non-alphabet characters in encoded data, use of different encoding alphabets, and canonical encodings. [STANDARDS-TRACK]</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="4648"/>
  <seriesInfo name="DOI" value="10.17487/RFC4648"/>
</reference-->

<!--reference anchor="RFC6234" target="https://www.rfc-editor.org/info/rfc6234" quoteTitle="true" derivedAnchor="RFC6234">
  <front>
    <title>US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)</title>
    <author fullname="D. Eastlake 3rd" initials="D." surname="Eastlake 3rd"/>
    <author fullname="T. Hansen" initials="T." surname="Hansen"/>
    <date month="May" year="2011"/>
    <abstract>
      <t indent="0">Federal Information Processing Standard, FIPS</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="6234"/>
  <seriesInfo name="DOI" value="10.17487/RFC6234"/>
</reference-->

<reference anchor="GBT.32918.5-2017" target="http://www.gmbz.org.cn/upload/2018-07-24/1532401863206085511.pdf" quoteTitle="true" derivedAnchor="GBT.32918.5-2017">
  <front>
    <title>Information security technology --- Public key cryptographic algorithm SM2 based on elliptic curves --- Part 5: Parameter definition</title>
    <author>
      <organization showOnFrontPage="true">Standardization Administration of the People's Republic of China</organization>
    </author>
    <date year="2017" month="December"/>
  </front>
  <seriesInfo name="GB/T" value="32918.5-2017"/>
</reference>

<reference anchor="FIPS186-4" target="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf" quoteTitle="true" derivedAnchor="FIPS186-4">
  <front>
    <title>Digital Signature Standard (DSS)</title>
    <author>
      <organization showOnFrontPage="true">National Institute of Standards and Technology (NIST)</organization>
    </author>
    <date year="2013" month="July"/>
  </front>
  <seriesInfo name="FIPS" value="186-4"/>
  <seriesInfo name="DOI" value="10.6028/NIST.FIPS.186-4"/>
</reference>

<reference anchor="RFC7748" target="https://www.rfc-editor.org/info/rfc7748" quoteTitle="true" derivedAnchor="RFC7748">
  <front>
    <title>Elliptic Curves for Security</title>
    <author fullname="A. Langley" initials="A." surname="Langley"/>
    <author fullname="M. Hamburg" initials="M." surname="Hamburg"/>
    <author fullname="S. Turner" initials="S." surname="Turner"/>
    <date month="January" year="2016"/>
    <abstract>
      <t indent="0">This memo specifies two elliptic curves over prime fields that offer a high level of practical security in cryptographic applications, including Transport Layer Security (TLS). These curves are intended to operate at the ~128-bit and ~224-bit security level, respectively, and are generated deterministically based on a list of required properties.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="7748"/>
  <seriesInfo name="DOI" value="10.17487/RFC7748"/>
</reference>

<reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" quoteTitle="true" derivedAnchor="RFC2119">
  <front>
    <title>Key words for use in RFCs to Indicate Requirement Levels</title>
    <author initials="S." surname="Bradner" fullname="S. Bradner">
      <organization showOnFrontPage="true"/>
    </author>
    <date year="1997" month="March"/>
    <abstract>
      <t indent="0">In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
    </abstract>
  </front>
  <seriesInfo name="BCP" value="14"/>
  <seriesInfo name="RFC" value="2119"/>
  <seriesInfo name="DOI" value="10.17487/RFC2119"/>
</reference>

<reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" quoteTitle="true" derivedAnchor="RFC8174">
  <front>
    <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
    <author initials="B." surname="Leiba" fullname="B. Leiba">
      <organization showOnFrontPage="true"/>
    </author>
    <date year="2017" month="May"/>
    <abstract>
      <t indent="0">RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
    </abstract>
  </front>
  <seriesInfo name="BCP" value="14"/>
  <seriesInfo name="RFC" value="8174"/>
  <seriesInfo name="DOI" value="10.17487/RFC8174"/>
</reference>

<reference anchor="RFC9266" target="https://www.rfc-editor.org/info/rfc9266" quoteTitle="true" derivedAnchor="RFC9266">
  <front>
  <title>Channel Bindings for TLS 1.3</title>
  <author fullname="S. Whited" initials="S." surname="Whited"/>
  <date month="July" year="2022"/>
  <abstract>
  <t indent="0">This document defines a channel binding type, tls-exporter, that is compatible with TLS 1.3 in accordance with RFC 5056, "On the Use of Channel Bindings to Secure Channels". Furthermore, it updates the default channel binding to the new binding for versions of TLS greater than 1.2. This document updates RFCs 5801, 5802, 5929, and 7677.</t>
  </abstract>
  </front>
  <seriesInfo name="RFC" value="9266"/>
  <seriesInfo name="DOI" value="10.17487/RFC9266"/>
</reference>

</references>

<references title='Informative References' anchor="sec-informative-references">

<reference anchor = "Meadows86" target = "https://doi.org/10.1109/SP.1986.10022" quoteTitle="true" derivedAnchor="Meadows86">
  <front>
  <title>A More Efficient Cryptographic Matchmaking Protocol for Use in the Absence of a Continuously Available Third Party</title>
  <author surname = "Meadows" fullname = "Catherine Meadows">
    <organization showOnFrontPage = "true">Naval Research Laboratory</organization>
  </author>
  </front>
  <refcontent>
  1986 IEEE Symposium on Security and Privacy
  </refcontent>
</reference>

<reference anchor = "IMC" target = "" quoteTitle="true" derivedAnchor="IMC">
  <front>
    <title>Introduction to Modern Cryptography, Third Edition</title>
    <author surname = "Katz" fullname = "Jonathan Katz">
      <organization showOnFrontPage = "true">University of Maryland</organization>
    </author>
    <author surname = "Lindell" fullname = "Yehuda Lindell">
      <organization showOnFrontPage = "true">Bar-Ilan University</organization>
    </author>
  </front>
</reference>

<reference anchor = "BG04" target = "https://eprint.iacr.org/2024/306" quoteTitle="true" derivedAnchor="MRH04">
  <front>
    <title>The Static Diffie-Hellman Problem</title>
    <author surname = "Brown" fullname = "Daniel R. L. Brown">
      <organization>Certicom Research</organization>
    </author>
    <author surname = "Gallant" fullname = "Robert P. Gallant">
      <organization>Certicom Research</organization>
    </author>
  </front>
</reference>

<reference anchor="MRH04" target="https://doi.org/10.1007/978-3-540-24638-1_2" quoteTitle="true" derivedAnchor="MRH04">
  <front>
    <title>Indifferentiability, Impossibility Results on Reductions, and Applications to the Random Oracle Methodology</title>
    <author initials="U." surname="Maurer" fullname="Ueli Maurer">
      <organization showOnFrontPage="true">ETH Zurich</organization>
    </author>
    <author initials="R." surname="Renner" fullname="Renato Renner">
      <organization showOnFrontPage="true">ETH Zurich</organization>
    </author>
    <author initials="C." surname="Holenstein" fullname="Clemens Holenstein">
      <organization showOnFrontPage="true">ETH Zurich</organization>
    </author>
    <date year="2004" month="February"/>
  </front>
  <refcontent>In TCC 2004: Theory of Cryptography, pages 21-39</refcontent>
  <seriesInfo name="DOI" value="10.1007/978-3-540-24638-1_2"/>
</reference>

<reference anchor = "Gra10" target = "https://doi.org/10.1007/978-3-642-17373-8_17"  quoteTitle = "true" derivedAnchor = "Gra10">
  <front>
    <title>On the Static Diffie-Hellman Problem on Elliptic Curves over Extension Fields</title>
    <author surname = "Granger" fullname = "Robert Granger">
      <organization>Claude Shannon Institute</organization>
    </author>
  </front>
  <refcontent>Advances in Cryptology - ASIACRYPT 2010.</refcontent>
  <seriesInfo name = "DOI" value = "https://doi.org/10.1007/978-3-642-17373-8_17"/>
</reference>

<reference anchor = "MU10" target = "https://doi.org/10.1504/IJACT.2010.038308" quoteTitle = "true" derivedAnchor = "MU10">
  <front>
    <title>On reusing ephemeral keys in Diffie-Hellman key agreement protocols</title>
    <author surname="Menezes" fullname="Alfred Menezes">
      <organization>University of Waterloo</organization>
    </author>
    <author surname = "Ustaoglu" fullname = "Berkant Ustaoglu">
      <organization>Okamoto Research Laboratory</organization>
    </author>
  </front>
  <refcontent>International Journal of Applied Cryptography (IJACT), Vol. 2, No. 2, 2010</refcontent>
  <seriesInfo name = "DOI" value = "https://doi.org/10.1504/IJACT.2010.038308"/>
</reference>

<reference anchor = "JV13" target = "https://doi.org/10.1007/s00145-011-9116-z" quoteTitle = "true" derivedAnchor = "JV13">
  <front>
    <title>Elliptic Curve Discrete Logarithm Problem over Small Degree Extension Fields - Application to the Static Diffie-Hellman Problem on $E(\mathbb{F}_{q{5}})$</title>
    <author surname = "Joux" fullname = "Antoine Joux">
      <organization>DGA and Laboratoire PRISM</organization>
    </author>
    <author surname = "Vitse" fullname = "Vanessa Vitse">
      <organization>Laboratoire PRISM</organization>
    </author>
  </front>
  <refcontent>Journal of Cryptology, Volume 26, pages 119â143, (2013)</refcontent>
  <seriesInfo name = "DOI" value = "https://doi.org/10.1007/s00145-011-9116-z"/>
</reference>

<reference anchor = "LOGJAM" target = "https://doi.org/10.1145/2810103.2813707"
  quoteTitle="true" derivedAnchor="LOGJAM" >
  <front>
    <title>Imperfect Forward Secrecy: How Diffie-Hellman Fails in Practice</title>
    <author surname = "Adrian" fullname = "David Adrian">
      <organization showOnFrontPage = "true">University of Michigan</organization>
    </author>
    <author surname = "Bhargavan" fullname = "Karthikeyan Bhargavan">
      <organization showOnFrontPage = "true">INRIA Paris-Rocquencourt</organization>
    </author>
    <author surname = "Durumeric" fullname = "Zakir Durumeric">
      <organization showOnFrontPage = "true">University of Michigan</organization>
    </author>
    <author surname = "Gaudry" fullname = "Pierrick Gaudry">
      <organization showOnFrontPage = "true">INRIA Nancy-Grand Est, CNRS, and UniversitÃ© de Lorraine</organization>
    </author>
    <author surname = "Green" fullname = "Matthew Green">
      <organization showOnFrontPage = "true">Johns Hopkins</organization>
    </author>
    <author surname = "Halderman" fullname = "J. Alex Halderman">
      <organization showOnFrontPage = "true">University of Michigan</organization>
    </author>
    <author surname = "Heninger" fullname = "Nadia Heninger">
      <organization showOnFrontPage = "true">University of Pennsylvania</organization>
    </author>
    <author surname = "Springall" fullname = "Drew Springall">
      <organization showOnFrontPage = "true">University of Michigan</organization>
    </author>
    <author surname = "ThomÃ©" fullname = "Emmanuel ThomÃ©">
      <organization showOnFrontPage = "true">INRIA Nancy-Grand Est, CNRS, and UniversitÃ© de Lorraine</organization>
    </author>
    <author surname = "Valenta" fullname = "Luke Valenta">
      <organization showOnFrontPage = "true">University of Pennsylvania</organization>
    </author>
    <author surname = "VanderSloot" fullname = "Benjamin VanderSloot">
      <organization showOnFrontPage = "true">University of Michigan</organization>
    </author>
    <author surname = "Wustrow" fullname = "Eric Wustrow">
      <organization showOnFrontPage = "true">University of Michigan</organization>
    </author>
    <author surname = "Zanella-BÃ©guelin" fullname = "Santiago Zanella-BÃ©guelin">
      <organization showOnFrontPage = "true">Microsoft Research</organization>
    </author>
    <author surname = "Zimmermann" fullname = "Paul Zimmermann">
      <organization showOnFrontPage = "true">University of Pennsylvania</organization>
    </author>
    <date year="2015" month="October"/>
  </front>
    <refcontent>
    Proceedings of the 22nd {ACM} {SIGSAC} Conference on Computer and
    Communications Security, Denver, CO, USA, October 12-16, 2015
    </refcontent>
</reference>

<reference anchor = "KKRT16" target = "https://doi.org/10.1145/2976749.2978381"
quoteTitle="true" derivedAnchor="KKRT16">
  <front>
    <title>Efficient Batched Oblivious {PRF} with Applications to Private Set Intersection</title>
    <author surname="Kolesnikov" fullname="Vladimir Kolesnikov">
      <organization showOnFrontPage="true">Bell Labs</organization>
    </author>
    <author  surname="Kumaresan" fullname="Ranjit Kumaresan">
      <organization showOnFrontPage="true">MIT</organization>
    </author>
    <author surname="Rosulek" fullname="Mike Rosulek">
      <organization showOnFrontPage="true">Oregon State University</organization>
    </author>
    <author surname="Trieu" fullname="Ni Trieu">
      <organization showOnFrontPage="true">Oregon State University</organization>
    </author>
    <date year="2016" month="October"/>
  </front>
  <refcontent>
  Proceedings of the 2016 {ACM} {SIGSAC} Conference on Computer and
  Communications Security, Vienna, Austria, October 24-28, 2016
  </refcontent>
</reference>

<reference anchor = "CHLR18" target = "https://doi.org/10.1145/3243734.3243836"
quoteTitle="true" derivedAnchor="CHLR18">
  <front>
    <title>Labeled PSI from Fully Homomorphic Encryption with Malicious Security</title>
    <author surname="Chen" fullname="Hao Chen">
      <organization showOnFrontPage="true">Microsoft Research</organization>
    </author>
    <author  surname="Huang" fullname="Zhicong Huang">
      <organization showOnFrontPage="true">Ãcole Polytechnique FÃ©dÃ©rale de Lausanne</organization>
    </author>
    <author surname="Laine" fullname="Kim Laine">
      <organization showOnFrontPage="true">Microsoft Research</organization>
    </author>
    <author surname="Rindal" fullname="Peter Rindal">
      <organization showOnFrontPage="true">Oregon State University</organization>
    </author>
    <date year="2018" month="October"/>
  </front>
  <refcontent>
  Proceedings of the 2018 {ACM} {SIGSAC} Conference on Computer and
  Communications Security, {CCS} 2018, Toronto, ON, Canada, October
  15-19, 2018
  </refcontent>
</reference>

<reference anchor = "CY20" target = "https://eprint.iacr.org/2020/901.pdf" quoteTitle="true" derivedAnchor="CY20">
  <front>
    <title>A Not-SO-Trival Replay Attack Against DH-PSI</title>
    <author surname = "Cui" fullname = "Hongrui Cui">
      <organization showOnFrontPage="true"> Shanghai Jiao Tong University</organization>
    </author>
    <author surname = "Yu" fullname = "Yu Yu">
      <organization showOnFrontPage="true"> Shanghai Jiao Tong University</organization>
    </author>
  </front>
</reference>

<reference anchor = "MS21" target = "https://www.microsoft.com/en-us/research/blog/password-monitor-safeguarding-passwords-in-microsoft-edge/"
  quoteTitle="true" derivedAnchor="MS21">
  <front>
    <title>Password Monitor: Safeguarding passwords in Microsoft Edge</title>
    <author surname = "Lauter" fullname = "Kristin Lauter">
      <organization showOnFrontPage="true">Microsoft</organization>
    </author>
    <author surname = "Kannepalli" fullname = "Sreekanth Kannepalli">
      <organization showOnFrontPage="true">Microsoft</organization>
    </author>
    <author surname = "Laine" fullname = "Kim Laine">
      <organization showOnFrontPage="true">Microsoft</organization>
    </author>
    <author surname = "Moreno" fullname = "Radames Cruz Moreno">
      <organization showOnFrontPage="true">Microsoft</organization>
    </author>
  </front>
</reference>

<reference anchor = "RR22" target = "https://doi.org/10.1145/3548606.3560658"
quoteTitle="true" derivedAnchor="RR22">
  <front>
    <title>Blazing Fast PSI from Improved OKVS and Subfield VOLE</title>
    <author surname="Raghuraman" fullname="Srinivasan Raghuraman">
      <organization showOnFrontPage="true">Visa Research</organization>
    </author>
    <author  surname="Rindal" fullname="Peter Rindal">
      <organization showOnFrontPage="true">Visa Research</organization>
    </author>
    <date year="2022" month="November"/>
  </front>
  <refcontent>
  Proceedings of the 2022 {ACM} {SIGSAC} Conference on Computer and
  Communications Security, {CCS} 2022, Los Angeles, CA, USA, November
  7-11, 2022
  </refcontent>
</reference>

<!--reference anchor="CZZDL24" target="https://doi.org/10.1007/978-3-031-57725-3_13" quoteTitle="true" derivedAnchor="CZZDL24">
  <front>
    <title>Private Set Operations from Multi-query Reverse Private Membership Test</title>
    <author surname="Chen" fullname="Yu Chen">
      <organization showOnFrontPage="true">Shandong University</organization>
    </author>
    <author  surname="Zhang" fullname="Min Zhang">
      <organization showOnFrontPage="true">Shandong University</organization>
    </author>
    <author surname="Zhang" fullname="Cong Zhang">
      <organization showOnFrontPage="true">SKLOIS, IIE, Chinese Academy of Sciences</organization>
    </author>
    <author surname="Dong" fullname="Minglang Dong">
      <organization showOnFrontPage="true">Shandong University</organization>
    </author>
    <author surname="Liu" fullname="Weiran Liu">
      <organization showOnFrontPage="true">Alibaba Group</organization>
    </author>
    <date year="2024" month="April"/>
  </front>
  <refcontent>
  Public-Key Cryptography - {PKC} 2024 - 27th {IACR} International Conference on Practice and Theory of Public-Key Cryptography, 2024, Proceedings, Part {III}
  </refcontent>
</reference-->

 <reference anchor="ISO-SM2" target="https://www.iso.org/standard/76382.html" quoteTitle="true" derivedAnchor="ISO-SM2">
  <front>
    <title>IT Security techniques -- Digital signatures with appendix -- Part 3: Discrete logarithm based mechanisms</title>
    <author>
      <organization showOnFrontPage="true">International Organization for Standardization</organization>
    </author>
    <date year="2018" month="November"/>
  </front>
  <seriesInfo name="ISO/IEC" value="14888-3:2018"/>
</reference>
<reference anchor="ISO-SM3" target="https://www.iso.org/standard/67116.html" quoteTitle="true" derivedAnchor="ISO-SM3">
  <front>
    <title>IT Security techniques -- Hash-functions -- Part 3: Dedicated hash-functions</title>
    <author>
      <organization showOnFrontPage="true">International Organization for Standardization</organization>
    </author>
    <date year="2018" month="October"/>
  </front>
  <seriesInfo name="ISO/IEC" value="10118-3:2018"/>
</reference>

<reference anchor="RFC5056" target="https://www.rfc-editor.org/info/rfc5056" quoteTitle="true" derivedAnchor="RFC5056">
  <front>
  <title>On the Use of Channel Bindings to Secure Channels</title>
  <author initials="N." surname="Williams" fullname="N. Williams">
  <organization showOnFrontPage="true"/>
  </author>
  <date year="2007" month="November"/>
  <abstract>
  <t indent="0">The concept of channel binding allows applications to establish that the two end-points of a secure channel at one network layer are the same as at a higher layer by binding authentication at the higher layer to the channel at the lower layer. This allows applications to delegate session protection to lower layers, which has various performance benefits.</t>
  <t indent="0">This document discusses and formalizes the concept of channel binding to secure channels. [STANDARDS-TRACK]</t>
  </abstract>
  </front>
  <seriesInfo name="RFC" value="5056"/>
  <seriesInfo name="DOI" value="10.17487/RFC5056"/>
</reference>

<reference anchor="RFC8031" target="https://www.rfc-editor.org/info/rfc8031" quoteTitle="true" derivedAnchor="RFC8031">
  <front>
    <title>Curve25519 and Curve448 for the Internet Key Exchange Protocol Version 2 (IKEv2) Key Agreement</title>
    <author initials="Y." surname="Nir" fullname="Y. Nir">
      <organization showOnFrontPage="true"/>
    </author>
    <author initials="S." surname="Josefsson" fullname="S. Josefsson">
      <organization showOnFrontPage="true"/>
    </author>
    <date year="2016" month="December"/>
    <abstract>
      <t indent="0">This document describes the use of Curve25519 and Curve448 for ephemeral key exchange in the Internet Key Exchange Protocol Version 2 (IKEv2).</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="8031"/>
  <seriesInfo name="DOI" value="10.17487/RFC8031"/>
</reference>

<reference anchor="RFC8446" target="https://www.rfc-editor.org/info/rfc8446" quoteTitle="true" derivedAnchor="RFC8446">
  <front>
    <title>The Transport Layer Security (TLS) Protocol Version 1.3</title>
    <author initials="E." surname="Rescorla" fullname="E. Rescorla">
      <organization showOnFrontPage="true"/>
    </author>
    <date year="2018" month="August"/>
    <abstract>
      <t indent="0">This document specifies version 1.3 of the Transport Layer Security (TLS) protocol.  TLS allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery.</t>
      <t indent="0">This document updates RFCs 5705 and 6066, and obsoletes RFCs 5077, 5246, and 6961.  This document also specifies new requirements for TLS 1.2 implementations.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="8446"/>
  <seriesInfo name="DOI" value="10.17487/RFC8446"/>
</reference>

<reference anchor="RFC8998" target="https://www.rfc-editor.org/info/rfc8998" quoteTitle="true" derivedAnchor="RFC8998">
  <front>
    <title>ShangMi (SM) Cipher Suites for TLS 1.3</title>
    <author initials="P." surname="Yang" fullname="Paul Yang">
      <organization showOnFrontPage="true"/>
    </author>
    <date year="2021" month="March"/>
    <abstract>
      <t indent="0">This document specifies how to use the ShangMi (SM) cryptographic algorithms with Transport Layer Security (TLS) protocol version 1.3.</t>
      <t indent="0">The use of these algorithms with TLS 1.3 is not endorsed by the IETF. The SM algorithms are becoming mandatory in China, so this document provides a description of how to use the SM algorithms with TLS 1.3 and specifies a profile of TLS 1.3 so that implementers can produce interworking implementations.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="8998"/>
  <seriesInfo name="DOI" value="10.17487/RFC8998"/>
</reference>

<reference anchor="RFC9497" target="https://www.rfc-editor.org/info/rfc9497" quoteTitle="true" derivedAnchor="OPRF">
  <front>
    <title>Oblivious Pseudorandom Functions (OPRFs) Using Prime-Order Groups</title>
    <author fullname="A. Davidson" initials="A." surname="Davidson"/>
    <author fullname="A. Faz-Hernandez" initials="A." surname="Faz-Hernandez"/>
    <author fullname="N. Sullivan" initials="N." surname="Sullivan"/>
    <author fullname="C. A. Wood" initials="C. A." surname="Wood"/>
    <date month="December" year="2023"/>
    <abstract>
      <t indent="0">An Oblivious Pseudorandom Function (OPRF) is a two-party protocol between a client and a server for computing the output of a Pseudorandom Function (PRF). The server provides the PRF private key, and the client provides the PRF input. At the end of the protocol, the client learns the PRF output without learning anything about the PRF private key, and the server learns neither the PRF input nor output. An OPRF can also satisfy a notion of 'verifiability', called a VOPRF. A VOPRF ensures clients can verify that the server used a specific private key during the execution of the protocol. A VOPRF can also be partially oblivious, called a POPRF. A POPRF allows clients and servers to provide public input to the PRF computation. This document specifies an OPRF, VOPRF, and POPRF instantiated within standard prime-order groups, including elliptic curves. This document is a product of the Crypto Forum Research Group (CFRG) in the IRTF.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="9497"/>
  <seriesInfo name="DOI" value="10.17487/RFC9497"/>
</reference>

<reference anchor="RFC9382" target="https://www.rfc-editor.org/info/rfc9382" quoteTitle="true" derivedAnchor="RFC9382">
  <front>
    <title>SPAKE2, a Password-Authenticated Key Exchange</title>
    <author fullname="W. Ladd" initials="W." surname="Ladd"/>
    <date month="September" year="2023"/>
    <abstract>
      <t indent="0">This document describes SPAKE2, which is a protocol for two parties that share a password to derive a strong shared key without disclosing the password.  This method is compatible with any group, is computationally efficient, and has a security proof.  This document predated the Crypto Forum Research Group (CFRG) password-authenticated key exchange (PAKE) competition, and it was not selected; however, given existing use of variants in Kerberos and other applications, it was felt that publication was beneficial. Applications that need a symmetric PAKE, but are unable to hash onto an elliptic curve at execution time, can use SPAKE2.  This document is a product of the Crypto Forum Research Group in the Internet Research Task Force (IRTF).</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="9382"/>
  <seriesInfo name="DOI" value="10.17487/RFC9382"/>
</reference>

  <reference anchor="I-D.ietf-ppm-dap" target="https://datatracker.ietf.org/doc/html/draft-ietf-ppm-dap-12">
    <front>
      <title>Distributed Aggregation Protocol for Privacy Preserving Measurement</title>
    <author initials="T." surname="Geoghegan" fullname="Tim Geoghegan">
      <organization>ISRG</organization>
    </author>
      <author initials="C." surname="Patton" fullname="Christopher Patton">
      <organization>Cloudflare</organization>
    </author>
      <author initials="B." surname="Pitman" fullname="Brandon Pitman">
      <organization>ISRG</organization>
    </author>
      <author initials="E." surname="Rescorla" fullname="Eric Rescorla">
      <organization>Independent</organization>
    </author>
      <author initials="C. A." surname="Wood" fullname="Christopher A. Wood">
      <organization>Cloudflare</organization>
    </author>
      <date month="October" day="10" year="2024"/>
    </front>
    <seriesInfo name="Internet-Draft" value="draft-ietf-ppm-dap-12"/>
  </reference>

  <reference anchor="draft-irtf-cfrg-vdaf-12">
    <front>
      <title>Verifiable Distributed Aggregation Functions</title>
      <author fullname="Richard Barnes" initials="R." surname="Barnes">
        <organization>Cisco</organization>
      </author>
      <author fullname="David Cook" initials="D." surname="Cook">
        <organization>ISRG</organization>
      </author>
      <author fullname="Christopher Patton" initials="C." surname="Patton">
        <organization>Cloudflare</organization>
      </author>
      <author fullname="Phillipp Schoppmann" initials="P." surname="Schoppmann">
        <organization>Google</organization>
      </author>
      <date day="4" month="October" year="2024"/>
    </front>
    <seriesInfo name="Internet-Draft" value="draft-irtf-cfrg-vdaf-12"/>
  </reference>

</references>


<?line 340?>

</back>

</rfc>

